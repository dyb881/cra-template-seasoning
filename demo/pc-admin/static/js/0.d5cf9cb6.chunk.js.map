{"version":3,"sources":["../node_modules/exif-rotate-js/lib/index.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator.js","../node_modules/exif-rotate-js/lib/utils/readImage.js","../node_modules/exif-rotate-js/lib/options.js","../node_modules/exif-rotate-js/lib/getBase64Strings.js","../node_modules/exif-rotate-js/lib/utils/getImages.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty.js","../node_modules/exif-js/exif.js","../node_modules/exif-rotate-js/lib/utils/readFile.js","../node_modules/exif-rotate-js/lib/utils/getBrowserOrientation.js"],"names":["__createBinding","this","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__exportStar","exports","p","prototype","hasOwnProperty","call","value","require","asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","error","done","Promise","then","module","fn","self","args","arguments","apply","err","readImage","src","img","Image","onload","onerror","defaultOptions","maxSize","type","getBase64Strings","getImages_1","options_1","getBrowserOrientation_1","files","canvas","document","createElement","context","getContext","Error","getImages","images","getBrowserOrientation","base64s","map","image","getSize","width","height","setAttribute","drawImage","toDataURL","orientation","getOrientation","getCanvasOptions","translate","scale","rotate","x","y","angle","EXIF","readFile_1","readImage_1","getDataFromReadFile","datas","all","item","parseWidth","parseHeight","getData","getTag","options","Math","PI","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","target","i","length","source","forEach","getOwnPropertyDescriptors","defineProperties","obj","configurable","writable","debug","EXIFwrapped","ExifTags","Tags","TiffTags","GPSTags","0","IFD1Tags","StringValues","ExposureProgram","1","2","3","4","5","6","7","8","MeteringMode","255","LightSource","9","10","11","12","13","14","15","17","18","19","20","21","22","23","24","Flash","SensingMethod","SceneCaptureType","SceneType","CustomRendered","WhiteBalance","GainControl","Contrast","Saturation","Sharpness","SubjectDistanceRange","FileSource","Components","imageHasData","exifdata","getImageData","callback","handleBinaryFile","binFile","data","findEXIFinJPEG","iptcdata","file","dataView","DataView","getUint8","offset","byteLength","isFieldSegmentStart","nameHeaderLength","readIPTCData","getUint16","findIPTCinJPEG","isXmpEnabled","xmpdata","dom","DOMParser","getStringFromDB","startOffset","sectionLength","xmpString","xmpEndIndex","indexOf","indexOfXmp","substring","slice","xml2Object","parseFromString","findXMPinJPEG","test","base64","contentType","match","replace","binary","atob","len","buffer","ArrayBuffer","view","Uint8Array","charCodeAt","base64ToArrayBuffer","fileReader","FileReader","e","result","url","http","XMLHttpRequest","open","responseType","status","response","send","objectURLToBlob","blob","readAsArrayBuffer","Blob","File","readEXIFData","IptcFieldMap","fieldValue","fieldName","dataSize","segmentType","segmentStartPos","getInt16","Array","readTags","tiffStart","dirStart","strings","bigEnd","entryOffset","entries","tags","readTagValue","vals","val","n","numerator","denominator","numValues","getUint32","valueOffset","Number","getInt32","start","outstr","String","fromCharCode","tag","exifData","gpsData","tiffOffset","firstIFDOffset","ExifIFDPointer","GPSInfoIFDPointer","IFD1OffsetPointer","getNextIFDOffset","thumbTags","JpegIFOffset","JpegIFByteCount","tOffset","tLength","console","log","readThumbnailImage","xml2json","xml","json","nodeType","attributes","j","attribute","nodeName","nodeValue","hasChildNodes","childNodes","child","old","children","idx","itemAtt","dataKey","dataValue","textContent","message","enableXmp","disableXmp","HTMLImageElement","complete","getIptcTag","getAllTags","a","getAllIptcTags","pretty","strPretty","readFromBinaryFile","readFile","reader","readAsDataURL","from"],"mappings":"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","file":"static/js/0.d5cf9cb6.chunk.js","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./getBase64Strings\"), exports);\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readImage = void 0;\nfunction readImage(src) {\n    const img = new Image();\n    return new Promise((resolve, reject) => {\n        img.onload = () => resolve(img);\n        img.onerror = (error) => reject(error);\n        img.src = src;\n    });\n}\nexports.readImage = readImage;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultOptions = void 0;\nexports.defaultOptions = {\n    maxSize: 720,\n    type: 'image/jpeg',\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getBase64Strings = void 0;\nconst getImages_1 = require(\"./utils/getImages\");\nconst options_1 = require(\"./options\");\nconst getBrowserOrientation_1 = require(\"./utils/getBrowserOrientation\");\nexports.getBase64Strings = async (files, { maxSize = options_1.defaultOptions.maxSize, type = options_1.defaultOptions.type, } = {}) => {\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    if (!context) {\n        throw new Error('canvas can not created');\n    }\n    const images = await getImages_1.getImages(files);\n    const hasBrowserOrientation = await getBrowserOrientation_1.getBrowserOrientation();\n    if (hasBrowserOrientation) {\n        const base64s = images.map((image) => {\n            const { width, height } = getImages_1.getSize(image.width, image.height, maxSize);\n            canvas.setAttribute('width', `${width}px`);\n            canvas.setAttribute('height', `${height}px`);\n            context.drawImage(image, 0, 0, width, height);\n            return canvas.toDataURL(type);\n        });\n        return base64s;\n    }\n    const base64s = images.map((image) => {\n        const orientation = getImages_1.getOrientation(image);\n        const { width, height } = getImages_1.getSize(orientation > 4 ? image.height : image.width, orientation > 4 ? image.width : image.height, maxSize);\n        canvas.setAttribute('width', `${width}px`);\n        canvas.setAttribute('height', `${height}px`);\n        const { translate, scale, rotate } = getImages_1.getCanvasOptions(width, height, orientation);\n        context.translate(translate.x, translate.y);\n        context.scale(scale.x, scale.y);\n        context.rotate(rotate.angle);\n        // exif orientation values > 4 correspond to portrait orientation.\n        // width and height parameters must be swapped for landscape to ensure correct image display\n        if (orientation > 4) {\n            context.drawImage(image, 0, 0, height, width);\n        }\n        else {\n            context.drawImage(image, 0, 0, width, height);\n        }\n        return canvas.toDataURL(type);\n    });\n    return base64s;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCanvasOptions = exports.getOrientation = exports.getSize = exports.getImages = void 0;\nconst EXIF = require(\"exif-js\");\nconst readFile_1 = require(\"./readFile\");\nconst readImage_1 = require(\"./readImage\");\nconst options_1 = require(\"../options\");\nasync function getImages(files) {\n    const datas = await readFile_1.getDataFromReadFile(files);\n    return await Promise.all(datas.map((item) => readImage_1.readImage(item)));\n}\nexports.getImages = getImages;\nfunction getSize(width, height, maxSize = options_1.defaultOptions.maxSize) {\n    const parseWidth = maxSize < width ? maxSize : width;\n    const parseHeight = maxSize < height ? maxSize : height;\n    if (width > height) {\n        return {\n            width: parseWidth,\n            height: height * (parseWidth / width),\n        };\n    }\n    if (height > width) {\n        return {\n            width: width * (parseHeight / height),\n            height: parseHeight,\n        };\n    }\n    return {\n        width: parseWidth,\n        height: parseHeight,\n    };\n}\nexports.getSize = getSize;\nfunction getOrientation(img) {\n    let orientation = 1;\n    // @ts-ignore not string: https://github.com/exif-js/exif-js/pull/198\n    EXIF.getData(img, () => {\n        orientation = EXIF.getTag(img, 'Orientation');\n    });\n    return orientation;\n}\nexports.getOrientation = getOrientation;\nfunction getCanvasOptions(width, height, orientation) {\n    const options = {\n        translate: {\n            x: 0,\n            y: 0,\n        },\n        scale: {\n            x: 1,\n            y: 1,\n        },\n        rotate: {\n            angle: 0,\n        },\n    };\n    switch (orientation) {\n        case 2:\n            // horizontal flip\n            return {\n                ...options,\n                translate: {\n                    ...options.translate,\n                    x: width,\n                },\n                scale: {\n                    ...options.scale,\n                    x: -1,\n                },\n            };\n        case 3:\n            // 180° rotate left\n            return {\n                ...options,\n                translate: {\n                    x: width,\n                    y: height,\n                },\n                rotate: {\n                    angle: Math.PI,\n                },\n            };\n        case 4:\n            // vertical flip\n            return {\n                ...options,\n                translate: {\n                    ...options.translate,\n                    y: height,\n                },\n                scale: {\n                    ...options.scale,\n                    y: -1,\n                },\n            };\n        case 5:\n            // vertical flip + 90 rotate right\n            return {\n                ...options,\n                scale: {\n                    ...options.scale,\n                    x: -1,\n                },\n                rotate: {\n                    angle: (90 * Math.PI) / 180,\n                },\n            };\n        case 6:\n            // 90° rotate right\n            return {\n                ...options,\n                translate: {\n                    ...options.translate,\n                    x: width,\n                },\n                rotate: {\n                    angle: (90 * Math.PI) / 180,\n                },\n            };\n        case 7:\n            // horizontal flip + 90 rotate right\n            return {\n                ...options,\n                translate: {\n                    x: width,\n                    y: height,\n                },\n                rotate: {\n                    angle: (90 * Math.PI) / 180,\n                },\n                scale: {\n                    ...options.scale,\n                    y: -1,\n                },\n            };\n        case 8:\n            // 90° rotate left\n            return {\n                ...options,\n                translate: {\n                    ...options.translate,\n                    y: height,\n                },\n                rotate: {\n                    angle: -(90 * Math.PI) / 180,\n                },\n            };\n        default:\n            return options;\n    }\n}\nexports.getCanvasOptions = getCanvasOptions;\n","var defineProperty = require(\"./defineProperty\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = _objectSpread2;","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","(function() {\n\n    var debug = false;\n\n    var root = this;\n\n    var EXIF = function(obj) {\n        if (obj instanceof EXIF) return obj;\n        if (!(this instanceof EXIF)) return new EXIF(obj);\n        this.EXIFwrapped = obj;\n    };\n\n    if (typeof exports !== 'undefined') {\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = EXIF;\n        }\n        exports.EXIF = EXIF;\n    } else {\n        root.EXIF = EXIF;\n    }\n\n    var ExifTags = EXIF.Tags = {\n\n        // version tags\n        0x9000 : \"ExifVersion\",             // EXIF version\n        0xA000 : \"FlashpixVersion\",         // Flashpix format version\n\n        // colorspace tags\n        0xA001 : \"ColorSpace\",              // Color space information tag\n\n        // image configuration\n        0xA002 : \"PixelXDimension\",         // Valid width of meaningful image\n        0xA003 : \"PixelYDimension\",         // Valid height of meaningful image\n        0x9101 : \"ComponentsConfiguration\", // Information about channels\n        0x9102 : \"CompressedBitsPerPixel\",  // Compressed bits per pixel\n\n        // user information\n        0x927C : \"MakerNote\",               // Any desired information written by the manufacturer\n        0x9286 : \"UserComment\",             // Comments by user\n\n        // related file\n        0xA004 : \"RelatedSoundFile\",        // Name of related sound file\n\n        // date and time\n        0x9003 : \"DateTimeOriginal\",        // Date and time when the original image was generated\n        0x9004 : \"DateTimeDigitized\",       // Date and time when the image was stored digitally\n        0x9290 : \"SubsecTime\",              // Fractions of seconds for DateTime\n        0x9291 : \"SubsecTimeOriginal\",      // Fractions of seconds for DateTimeOriginal\n        0x9292 : \"SubsecTimeDigitized\",     // Fractions of seconds for DateTimeDigitized\n\n        // picture-taking conditions\n        0x829A : \"ExposureTime\",            // Exposure time (in seconds)\n        0x829D : \"FNumber\",                 // F number\n        0x8822 : \"ExposureProgram\",         // Exposure program\n        0x8824 : \"SpectralSensitivity\",     // Spectral sensitivity\n        0x8827 : \"ISOSpeedRatings\",         // ISO speed rating\n        0x8828 : \"OECF\",                    // Optoelectric conversion factor\n        0x9201 : \"ShutterSpeedValue\",       // Shutter speed\n        0x9202 : \"ApertureValue\",           // Lens aperture\n        0x9203 : \"BrightnessValue\",         // Value of brightness\n        0x9204 : \"ExposureBias\",            // Exposure bias\n        0x9205 : \"MaxApertureValue\",        // Smallest F number of lens\n        0x9206 : \"SubjectDistance\",         // Distance to subject in meters\n        0x9207 : \"MeteringMode\",            // Metering mode\n        0x9208 : \"LightSource\",             // Kind of light source\n        0x9209 : \"Flash\",                   // Flash status\n        0x9214 : \"SubjectArea\",             // Location and area of main subject\n        0x920A : \"FocalLength\",             // Focal length of the lens in mm\n        0xA20B : \"FlashEnergy\",             // Strobe energy in BCPS\n        0xA20C : \"SpatialFrequencyResponse\",    //\n        0xA20E : \"FocalPlaneXResolution\",   // Number of pixels in width direction per FocalPlaneResolutionUnit\n        0xA20F : \"FocalPlaneYResolution\",   // Number of pixels in height direction per FocalPlaneResolutionUnit\n        0xA210 : \"FocalPlaneResolutionUnit\",    // Unit for measuring FocalPlaneXResolution and FocalPlaneYResolution\n        0xA214 : \"SubjectLocation\",         // Location of subject in image\n        0xA215 : \"ExposureIndex\",           // Exposure index selected on camera\n        0xA217 : \"SensingMethod\",           // Image sensor type\n        0xA300 : \"FileSource\",              // Image source (3 == DSC)\n        0xA301 : \"SceneType\",               // Scene type (1 == directly photographed)\n        0xA302 : \"CFAPattern\",              // Color filter array geometric pattern\n        0xA401 : \"CustomRendered\",          // Special processing\n        0xA402 : \"ExposureMode\",            // Exposure mode\n        0xA403 : \"WhiteBalance\",            // 1 = auto white balance, 2 = manual\n        0xA404 : \"DigitalZoomRation\",       // Digital zoom ratio\n        0xA405 : \"FocalLengthIn35mmFilm\",   // Equivalent foacl length assuming 35mm film camera (in mm)\n        0xA406 : \"SceneCaptureType\",        // Type of scene\n        0xA407 : \"GainControl\",             // Degree of overall image gain adjustment\n        0xA408 : \"Contrast\",                // Direction of contrast processing applied by camera\n        0xA409 : \"Saturation\",              // Direction of saturation processing applied by camera\n        0xA40A : \"Sharpness\",               // Direction of sharpness processing applied by camera\n        0xA40B : \"DeviceSettingDescription\",    //\n        0xA40C : \"SubjectDistanceRange\",    // Distance to subject\n\n        // other tags\n        0xA005 : \"InteroperabilityIFDPointer\",\n        0xA420 : \"ImageUniqueID\"            // Identifier assigned uniquely to each image\n    };\n\n    var TiffTags = EXIF.TiffTags = {\n        0x0100 : \"ImageWidth\",\n        0x0101 : \"ImageHeight\",\n        0x8769 : \"ExifIFDPointer\",\n        0x8825 : \"GPSInfoIFDPointer\",\n        0xA005 : \"InteroperabilityIFDPointer\",\n        0x0102 : \"BitsPerSample\",\n        0x0103 : \"Compression\",\n        0x0106 : \"PhotometricInterpretation\",\n        0x0112 : \"Orientation\",\n        0x0115 : \"SamplesPerPixel\",\n        0x011C : \"PlanarConfiguration\",\n        0x0212 : \"YCbCrSubSampling\",\n        0x0213 : \"YCbCrPositioning\",\n        0x011A : \"XResolution\",\n        0x011B : \"YResolution\",\n        0x0128 : \"ResolutionUnit\",\n        0x0111 : \"StripOffsets\",\n        0x0116 : \"RowsPerStrip\",\n        0x0117 : \"StripByteCounts\",\n        0x0201 : \"JPEGInterchangeFormat\",\n        0x0202 : \"JPEGInterchangeFormatLength\",\n        0x012D : \"TransferFunction\",\n        0x013E : \"WhitePoint\",\n        0x013F : \"PrimaryChromaticities\",\n        0x0211 : \"YCbCrCoefficients\",\n        0x0214 : \"ReferenceBlackWhite\",\n        0x0132 : \"DateTime\",\n        0x010E : \"ImageDescription\",\n        0x010F : \"Make\",\n        0x0110 : \"Model\",\n        0x0131 : \"Software\",\n        0x013B : \"Artist\",\n        0x8298 : \"Copyright\"\n    };\n\n    var GPSTags = EXIF.GPSTags = {\n        0x0000 : \"GPSVersionID\",\n        0x0001 : \"GPSLatitudeRef\",\n        0x0002 : \"GPSLatitude\",\n        0x0003 : \"GPSLongitudeRef\",\n        0x0004 : \"GPSLongitude\",\n        0x0005 : \"GPSAltitudeRef\",\n        0x0006 : \"GPSAltitude\",\n        0x0007 : \"GPSTimeStamp\",\n        0x0008 : \"GPSSatellites\",\n        0x0009 : \"GPSStatus\",\n        0x000A : \"GPSMeasureMode\",\n        0x000B : \"GPSDOP\",\n        0x000C : \"GPSSpeedRef\",\n        0x000D : \"GPSSpeed\",\n        0x000E : \"GPSTrackRef\",\n        0x000F : \"GPSTrack\",\n        0x0010 : \"GPSImgDirectionRef\",\n        0x0011 : \"GPSImgDirection\",\n        0x0012 : \"GPSMapDatum\",\n        0x0013 : \"GPSDestLatitudeRef\",\n        0x0014 : \"GPSDestLatitude\",\n        0x0015 : \"GPSDestLongitudeRef\",\n        0x0016 : \"GPSDestLongitude\",\n        0x0017 : \"GPSDestBearingRef\",\n        0x0018 : \"GPSDestBearing\",\n        0x0019 : \"GPSDestDistanceRef\",\n        0x001A : \"GPSDestDistance\",\n        0x001B : \"GPSProcessingMethod\",\n        0x001C : \"GPSAreaInformation\",\n        0x001D : \"GPSDateStamp\",\n        0x001E : \"GPSDifferential\"\n    };\n\n     // EXIF 2.3 Spec\n    var IFD1Tags = EXIF.IFD1Tags = {\n        0x0100: \"ImageWidth\",\n        0x0101: \"ImageHeight\",\n        0x0102: \"BitsPerSample\",\n        0x0103: \"Compression\",\n        0x0106: \"PhotometricInterpretation\",\n        0x0111: \"StripOffsets\",\n        0x0112: \"Orientation\",\n        0x0115: \"SamplesPerPixel\",\n        0x0116: \"RowsPerStrip\",\n        0x0117: \"StripByteCounts\",\n        0x011A: \"XResolution\",\n        0x011B: \"YResolution\",\n        0x011C: \"PlanarConfiguration\",\n        0x0128: \"ResolutionUnit\",\n        0x0201: \"JpegIFOffset\",    // When image format is JPEG, this value show offset to JPEG data stored.(aka \"ThumbnailOffset\" or \"JPEGInterchangeFormat\")\n        0x0202: \"JpegIFByteCount\", // When image format is JPEG, this value shows data size of JPEG image (aka \"ThumbnailLength\" or \"JPEGInterchangeFormatLength\")\n        0x0211: \"YCbCrCoefficients\",\n        0x0212: \"YCbCrSubSampling\",\n        0x0213: \"YCbCrPositioning\",\n        0x0214: \"ReferenceBlackWhite\"\n    };\n\n    var StringValues = EXIF.StringValues = {\n        ExposureProgram : {\n            0 : \"Not defined\",\n            1 : \"Manual\",\n            2 : \"Normal program\",\n            3 : \"Aperture priority\",\n            4 : \"Shutter priority\",\n            5 : \"Creative program\",\n            6 : \"Action program\",\n            7 : \"Portrait mode\",\n            8 : \"Landscape mode\"\n        },\n        MeteringMode : {\n            0 : \"Unknown\",\n            1 : \"Average\",\n            2 : \"CenterWeightedAverage\",\n            3 : \"Spot\",\n            4 : \"MultiSpot\",\n            5 : \"Pattern\",\n            6 : \"Partial\",\n            255 : \"Other\"\n        },\n        LightSource : {\n            0 : \"Unknown\",\n            1 : \"Daylight\",\n            2 : \"Fluorescent\",\n            3 : \"Tungsten (incandescent light)\",\n            4 : \"Flash\",\n            9 : \"Fine weather\",\n            10 : \"Cloudy weather\",\n            11 : \"Shade\",\n            12 : \"Daylight fluorescent (D 5700 - 7100K)\",\n            13 : \"Day white fluorescent (N 4600 - 5400K)\",\n            14 : \"Cool white fluorescent (W 3900 - 4500K)\",\n            15 : \"White fluorescent (WW 3200 - 3700K)\",\n            17 : \"Standard light A\",\n            18 : \"Standard light B\",\n            19 : \"Standard light C\",\n            20 : \"D55\",\n            21 : \"D65\",\n            22 : \"D75\",\n            23 : \"D50\",\n            24 : \"ISO studio tungsten\",\n            255 : \"Other\"\n        },\n        Flash : {\n            0x0000 : \"Flash did not fire\",\n            0x0001 : \"Flash fired\",\n            0x0005 : \"Strobe return light not detected\",\n            0x0007 : \"Strobe return light detected\",\n            0x0009 : \"Flash fired, compulsory flash mode\",\n            0x000D : \"Flash fired, compulsory flash mode, return light not detected\",\n            0x000F : \"Flash fired, compulsory flash mode, return light detected\",\n            0x0010 : \"Flash did not fire, compulsory flash mode\",\n            0x0018 : \"Flash did not fire, auto mode\",\n            0x0019 : \"Flash fired, auto mode\",\n            0x001D : \"Flash fired, auto mode, return light not detected\",\n            0x001F : \"Flash fired, auto mode, return light detected\",\n            0x0020 : \"No flash function\",\n            0x0041 : \"Flash fired, red-eye reduction mode\",\n            0x0045 : \"Flash fired, red-eye reduction mode, return light not detected\",\n            0x0047 : \"Flash fired, red-eye reduction mode, return light detected\",\n            0x0049 : \"Flash fired, compulsory flash mode, red-eye reduction mode\",\n            0x004D : \"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected\",\n            0x004F : \"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected\",\n            0x0059 : \"Flash fired, auto mode, red-eye reduction mode\",\n            0x005D : \"Flash fired, auto mode, return light not detected, red-eye reduction mode\",\n            0x005F : \"Flash fired, auto mode, return light detected, red-eye reduction mode\"\n        },\n        SensingMethod : {\n            1 : \"Not defined\",\n            2 : \"One-chip color area sensor\",\n            3 : \"Two-chip color area sensor\",\n            4 : \"Three-chip color area sensor\",\n            5 : \"Color sequential area sensor\",\n            7 : \"Trilinear sensor\",\n            8 : \"Color sequential linear sensor\"\n        },\n        SceneCaptureType : {\n            0 : \"Standard\",\n            1 : \"Landscape\",\n            2 : \"Portrait\",\n            3 : \"Night scene\"\n        },\n        SceneType : {\n            1 : \"Directly photographed\"\n        },\n        CustomRendered : {\n            0 : \"Normal process\",\n            1 : \"Custom process\"\n        },\n        WhiteBalance : {\n            0 : \"Auto white balance\",\n            1 : \"Manual white balance\"\n        },\n        GainControl : {\n            0 : \"None\",\n            1 : \"Low gain up\",\n            2 : \"High gain up\",\n            3 : \"Low gain down\",\n            4 : \"High gain down\"\n        },\n        Contrast : {\n            0 : \"Normal\",\n            1 : \"Soft\",\n            2 : \"Hard\"\n        },\n        Saturation : {\n            0 : \"Normal\",\n            1 : \"Low saturation\",\n            2 : \"High saturation\"\n        },\n        Sharpness : {\n            0 : \"Normal\",\n            1 : \"Soft\",\n            2 : \"Hard\"\n        },\n        SubjectDistanceRange : {\n            0 : \"Unknown\",\n            1 : \"Macro\",\n            2 : \"Close view\",\n            3 : \"Distant view\"\n        },\n        FileSource : {\n            3 : \"DSC\"\n        },\n\n        Components : {\n            0 : \"\",\n            1 : \"Y\",\n            2 : \"Cb\",\n            3 : \"Cr\",\n            4 : \"R\",\n            5 : \"G\",\n            6 : \"B\"\n        }\n    };\n\n    function addEvent(element, event, handler) {\n        if (element.addEventListener) {\n            element.addEventListener(event, handler, false);\n        } else if (element.attachEvent) {\n            element.attachEvent(\"on\" + event, handler);\n        }\n    }\n\n    function imageHasData(img) {\n        return !!(img.exifdata);\n    }\n\n\n    function base64ToArrayBuffer(base64, contentType) {\n        contentType = contentType || base64.match(/^data\\:([^\\;]+)\\;base64,/mi)[1] || ''; // e.g. 'data:image/jpeg;base64,...' => 'image/jpeg'\n        base64 = base64.replace(/^data\\:([^\\;]+)\\;base64,/gmi, '');\n        var binary = atob(base64);\n        var len = binary.length;\n        var buffer = new ArrayBuffer(len);\n        var view = new Uint8Array(buffer);\n        for (var i = 0; i < len; i++) {\n            view[i] = binary.charCodeAt(i);\n        }\n        return buffer;\n    }\n\n    function objectURLToBlob(url, callback) {\n        var http = new XMLHttpRequest();\n        http.open(\"GET\", url, true);\n        http.responseType = \"blob\";\n        http.onload = function(e) {\n            if (this.status == 200 || this.status === 0) {\n                callback(this.response);\n            }\n        };\n        http.send();\n    }\n\n    function getImageData(img, callback) {\n        function handleBinaryFile(binFile) {\n            var data = findEXIFinJPEG(binFile);\n            img.exifdata = data || {};\n            var iptcdata = findIPTCinJPEG(binFile);\n            img.iptcdata = iptcdata || {};\n            if (EXIF.isXmpEnabled) {\n               var xmpdata= findXMPinJPEG(binFile);\n               img.xmpdata = xmpdata || {};               \n            }\n            if (callback) {\n                callback.call(img);\n            }\n        }\n\n        if (img.src) {\n            if (/^data\\:/i.test(img.src)) { // Data URI\n                var arrayBuffer = base64ToArrayBuffer(img.src);\n                handleBinaryFile(arrayBuffer);\n\n            } else if (/^blob\\:/i.test(img.src)) { // Object URL\n                var fileReader = new FileReader();\n                fileReader.onload = function(e) {\n                    handleBinaryFile(e.target.result);\n                };\n                objectURLToBlob(img.src, function (blob) {\n                    fileReader.readAsArrayBuffer(blob);\n                });\n            } else {\n                var http = new XMLHttpRequest();\n                http.onload = function() {\n                    if (this.status == 200 || this.status === 0) {\n                        handleBinaryFile(http.response);\n                    } else {\n                        throw \"Could not load image\";\n                    }\n                    http = null;\n                };\n                http.open(\"GET\", img.src, true);\n                http.responseType = \"arraybuffer\";\n                http.send(null);\n            }\n        } else if (self.FileReader && (img instanceof self.Blob || img instanceof self.File)) {\n            var fileReader = new FileReader();\n            fileReader.onload = function(e) {\n                if (debug) console.log(\"Got file of length \" + e.target.result.byteLength);\n                handleBinaryFile(e.target.result);\n            };\n\n            fileReader.readAsArrayBuffer(img);\n        }\n    }\n\n    function findEXIFinJPEG(file) {\n        var dataView = new DataView(file);\n\n        if (debug) console.log(\"Got file of length \" + file.byteLength);\n        if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\n            if (debug) console.log(\"Not a valid JPEG\");\n            return false; // not a valid jpeg\n        }\n\n        var offset = 2,\n            length = file.byteLength,\n            marker;\n\n        while (offset < length) {\n            if (dataView.getUint8(offset) != 0xFF) {\n                if (debug) console.log(\"Not a valid marker at offset \" + offset + \", found: \" + dataView.getUint8(offset));\n                return false; // not a valid marker, something is wrong\n            }\n\n            marker = dataView.getUint8(offset + 1);\n            if (debug) console.log(marker);\n\n            // we could implement handling for other markers here,\n            // but we're only looking for 0xFFE1 for EXIF data\n\n            if (marker == 225) {\n                if (debug) console.log(\"Found 0xFFE1 marker\");\n\n                return readEXIFData(dataView, offset + 4, dataView.getUint16(offset + 2) - 2);\n\n                // offset += 2 + file.getShortAt(offset+2, true);\n\n            } else {\n                offset += 2 + dataView.getUint16(offset+2);\n            }\n\n        }\n\n    }\n\n    function findIPTCinJPEG(file) {\n        var dataView = new DataView(file);\n\n        if (debug) console.log(\"Got file of length \" + file.byteLength);\n        if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\n            if (debug) console.log(\"Not a valid JPEG\");\n            return false; // not a valid jpeg\n        }\n\n        var offset = 2,\n            length = file.byteLength;\n\n\n        var isFieldSegmentStart = function(dataView, offset){\n            return (\n                dataView.getUint8(offset) === 0x38 &&\n                dataView.getUint8(offset+1) === 0x42 &&\n                dataView.getUint8(offset+2) === 0x49 &&\n                dataView.getUint8(offset+3) === 0x4D &&\n                dataView.getUint8(offset+4) === 0x04 &&\n                dataView.getUint8(offset+5) === 0x04\n            );\n        };\n\n        while (offset < length) {\n\n            if ( isFieldSegmentStart(dataView, offset )){\n\n                // Get the length of the name header (which is padded to an even number of bytes)\n                var nameHeaderLength = dataView.getUint8(offset+7);\n                if(nameHeaderLength % 2 !== 0) nameHeaderLength += 1;\n                // Check for pre photoshop 6 format\n                if(nameHeaderLength === 0) {\n                    // Always 4\n                    nameHeaderLength = 4;\n                }\n\n                var startOffset = offset + 8 + nameHeaderLength;\n                var sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength);\n\n                return readIPTCData(file, startOffset, sectionLength);\n\n                break;\n\n            }\n\n\n            // Not the marker, continue searching\n            offset++;\n\n        }\n\n    }\n    var IptcFieldMap = {\n        0x78 : 'caption',\n        0x6E : 'credit',\n        0x19 : 'keywords',\n        0x37 : 'dateCreated',\n        0x50 : 'byline',\n        0x55 : 'bylineTitle',\n        0x7A : 'captionWriter',\n        0x69 : 'headline',\n        0x74 : 'copyright',\n        0x0F : 'category'\n    };\n    function readIPTCData(file, startOffset, sectionLength){\n        var dataView = new DataView(file);\n        var data = {};\n        var fieldValue, fieldName, dataSize, segmentType, segmentSize;\n        var segmentStartPos = startOffset;\n        while(segmentStartPos < startOffset+sectionLength) {\n            if(dataView.getUint8(segmentStartPos) === 0x1C && dataView.getUint8(segmentStartPos+1) === 0x02){\n                segmentType = dataView.getUint8(segmentStartPos+2);\n                if(segmentType in IptcFieldMap) {\n                    dataSize = dataView.getInt16(segmentStartPos+3);\n                    segmentSize = dataSize + 5;\n                    fieldName = IptcFieldMap[segmentType];\n                    fieldValue = getStringFromDB(dataView, segmentStartPos+5, dataSize);\n                    // Check if we already stored a value with this name\n                    if(data.hasOwnProperty(fieldName)) {\n                        // Value already stored with this name, create multivalue field\n                        if(data[fieldName] instanceof Array) {\n                            data[fieldName].push(fieldValue);\n                        }\n                        else {\n                            data[fieldName] = [data[fieldName], fieldValue];\n                        }\n                    }\n                    else {\n                        data[fieldName] = fieldValue;\n                    }\n                }\n\n            }\n            segmentStartPos++;\n        }\n        return data;\n    }\n\n\n\n    function readTags(file, tiffStart, dirStart, strings, bigEnd) {\n        var entries = file.getUint16(dirStart, !bigEnd),\n            tags = {},\n            entryOffset, tag,\n            i;\n\n        for (i=0;i<entries;i++) {\n            entryOffset = dirStart + i*12 + 2;\n            tag = strings[file.getUint16(entryOffset, !bigEnd)];\n            if (!tag && debug) console.log(\"Unknown tag: \" + file.getUint16(entryOffset, !bigEnd));\n            tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);\n        }\n        return tags;\n    }\n\n\n    function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {\n        var type = file.getUint16(entryOffset+2, !bigEnd),\n            numValues = file.getUint32(entryOffset+4, !bigEnd),\n            valueOffset = file.getUint32(entryOffset+8, !bigEnd) + tiffStart,\n            offset,\n            vals, val, n,\n            numerator, denominator;\n\n        switch (type) {\n            case 1: // byte, 8-bit unsigned int\n            case 7: // undefined, 8-bit byte, value depending on field\n                if (numValues == 1) {\n                    return file.getUint8(entryOffset + 8, !bigEnd);\n                } else {\n                    offset = numValues > 4 ? valueOffset : (entryOffset + 8);\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        vals[n] = file.getUint8(offset + n);\n                    }\n                    return vals;\n                }\n\n            case 2: // ascii, 8-bit byte\n                offset = numValues > 4 ? valueOffset : (entryOffset + 8);\n                return getStringFromDB(file, offset, numValues-1);\n\n            case 3: // short, 16 bit int\n                if (numValues == 1) {\n                    return file.getUint16(entryOffset + 8, !bigEnd);\n                } else {\n                    offset = numValues > 2 ? valueOffset : (entryOffset + 8);\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        vals[n] = file.getUint16(offset + 2*n, !bigEnd);\n                    }\n                    return vals;\n                }\n\n            case 4: // long, 32 bit int\n                if (numValues == 1) {\n                    return file.getUint32(entryOffset + 8, !bigEnd);\n                } else {\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        vals[n] = file.getUint32(valueOffset + 4*n, !bigEnd);\n                    }\n                    return vals;\n                }\n\n            case 5:    // rational = two long values, first is numerator, second is denominator\n                if (numValues == 1) {\n                    numerator = file.getUint32(valueOffset, !bigEnd);\n                    denominator = file.getUint32(valueOffset+4, !bigEnd);\n                    val = new Number(numerator / denominator);\n                    val.numerator = numerator;\n                    val.denominator = denominator;\n                    return val;\n                } else {\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        numerator = file.getUint32(valueOffset + 8*n, !bigEnd);\n                        denominator = file.getUint32(valueOffset+4 + 8*n, !bigEnd);\n                        vals[n] = new Number(numerator / denominator);\n                        vals[n].numerator = numerator;\n                        vals[n].denominator = denominator;\n                    }\n                    return vals;\n                }\n\n            case 9: // slong, 32 bit signed int\n                if (numValues == 1) {\n                    return file.getInt32(entryOffset + 8, !bigEnd);\n                } else {\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        vals[n] = file.getInt32(valueOffset + 4*n, !bigEnd);\n                    }\n                    return vals;\n                }\n\n            case 10: // signed rational, two slongs, first is numerator, second is denominator\n                if (numValues == 1) {\n                    return file.getInt32(valueOffset, !bigEnd) / file.getInt32(valueOffset+4, !bigEnd);\n                } else {\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        vals[n] = file.getInt32(valueOffset + 8*n, !bigEnd) / file.getInt32(valueOffset+4 + 8*n, !bigEnd);\n                    }\n                    return vals;\n                }\n        }\n    }\n\n    /**\n    * Given an IFD (Image File Directory) start offset\n    * returns an offset to next IFD or 0 if it's the last IFD.\n    */\n    function getNextIFDOffset(dataView, dirStart, bigEnd){\n        //the first 2bytes means the number of directory entries contains in this IFD\n        var entries = dataView.getUint16(dirStart, !bigEnd);\n\n        // After last directory entry, there is a 4bytes of data,\n        // it means an offset to next IFD.\n        // If its value is '0x00000000', it means this is the last IFD and there is no linked IFD.\n\n        return dataView.getUint32(dirStart + 2 + entries * 12, !bigEnd); // each entry is 12 bytes long\n    }\n\n    function readThumbnailImage(dataView, tiffStart, firstIFDOffset, bigEnd){\n        // get the IFD1 offset\n        var IFD1OffsetPointer = getNextIFDOffset(dataView, tiffStart+firstIFDOffset, bigEnd);\n\n        if (!IFD1OffsetPointer) {\n            // console.log('******** IFD1Offset is empty, image thumb not found ********');\n            return {};\n        }\n        else if (IFD1OffsetPointer > dataView.byteLength) { // this should not happen\n            // console.log('******** IFD1Offset is outside the bounds of the DataView ********');\n            return {};\n        }\n        // console.log('*******  thumbnail IFD offset (IFD1) is: %s', IFD1OffsetPointer);\n\n        var thumbTags = readTags(dataView, tiffStart, tiffStart + IFD1OffsetPointer, IFD1Tags, bigEnd)\n\n        // EXIF 2.3 specification for JPEG format thumbnail\n\n        // If the value of Compression(0x0103) Tag in IFD1 is '6', thumbnail image format is JPEG.\n        // Most of Exif image uses JPEG format for thumbnail. In that case, you can get offset of thumbnail\n        // by JpegIFOffset(0x0201) Tag in IFD1, size of thumbnail by JpegIFByteCount(0x0202) Tag.\n        // Data format is ordinary JPEG format, starts from 0xFFD8 and ends by 0xFFD9. It seems that\n        // JPEG format and 160x120pixels of size are recommended thumbnail format for Exif2.1 or later.\n\n        if (thumbTags['Compression']) {\n            // console.log('Thumbnail image found!');\n\n            switch (thumbTags['Compression']) {\n                case 6:\n                    // console.log('Thumbnail image format is JPEG');\n                    if (thumbTags.JpegIFOffset && thumbTags.JpegIFByteCount) {\n                    // extract the thumbnail\n                        var tOffset = tiffStart + thumbTags.JpegIFOffset;\n                        var tLength = thumbTags.JpegIFByteCount;\n                        thumbTags['blob'] = new Blob([new Uint8Array(dataView.buffer, tOffset, tLength)], {\n                            type: 'image/jpeg'\n                        });\n                    }\n                break;\n\n            case 1:\n                console.log(\"Thumbnail image format is TIFF, which is not implemented.\");\n                break;\n            default:\n                console.log(\"Unknown thumbnail image format '%s'\", thumbTags['Compression']);\n            }\n        }\n        else if (thumbTags['PhotometricInterpretation'] == 2) {\n            console.log(\"Thumbnail image format is RGB, which is not implemented.\");\n        }\n        return thumbTags;\n    }\n\n    function getStringFromDB(buffer, start, length) {\n        var outstr = \"\";\n        for (n = start; n < start+length; n++) {\n            outstr += String.fromCharCode(buffer.getUint8(n));\n        }\n        return outstr;\n    }\n\n    function readEXIFData(file, start) {\n        if (getStringFromDB(file, start, 4) != \"Exif\") {\n            if (debug) console.log(\"Not valid EXIF data! \" + getStringFromDB(file, start, 4));\n            return false;\n        }\n\n        var bigEnd,\n            tags, tag,\n            exifData, gpsData,\n            tiffOffset = start + 6;\n\n        // test for TIFF validity and endianness\n        if (file.getUint16(tiffOffset) == 0x4949) {\n            bigEnd = false;\n        } else if (file.getUint16(tiffOffset) == 0x4D4D) {\n            bigEnd = true;\n        } else {\n            if (debug) console.log(\"Not valid TIFF data! (no 0x4949 or 0x4D4D)\");\n            return false;\n        }\n\n        if (file.getUint16(tiffOffset+2, !bigEnd) != 0x002A) {\n            if (debug) console.log(\"Not valid TIFF data! (no 0x002A)\");\n            return false;\n        }\n\n        var firstIFDOffset = file.getUint32(tiffOffset+4, !bigEnd);\n\n        if (firstIFDOffset < 0x00000008) {\n            if (debug) console.log(\"Not valid TIFF data! (First offset less than 8)\", file.getUint32(tiffOffset+4, !bigEnd));\n            return false;\n        }\n\n        tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, TiffTags, bigEnd);\n\n        if (tags.ExifIFDPointer) {\n            exifData = readTags(file, tiffOffset, tiffOffset + tags.ExifIFDPointer, ExifTags, bigEnd);\n            for (tag in exifData) {\n                switch (tag) {\n                    case \"LightSource\" :\n                    case \"Flash\" :\n                    case \"MeteringMode\" :\n                    case \"ExposureProgram\" :\n                    case \"SensingMethod\" :\n                    case \"SceneCaptureType\" :\n                    case \"SceneType\" :\n                    case \"CustomRendered\" :\n                    case \"WhiteBalance\" :\n                    case \"GainControl\" :\n                    case \"Contrast\" :\n                    case \"Saturation\" :\n                    case \"Sharpness\" :\n                    case \"SubjectDistanceRange\" :\n                    case \"FileSource\" :\n                        exifData[tag] = StringValues[tag][exifData[tag]];\n                        break;\n\n                    case \"ExifVersion\" :\n                    case \"FlashpixVersion\" :\n                        exifData[tag] = String.fromCharCode(exifData[tag][0], exifData[tag][1], exifData[tag][2], exifData[tag][3]);\n                        break;\n\n                    case \"ComponentsConfiguration\" :\n                        exifData[tag] =\n                            StringValues.Components[exifData[tag][0]] +\n                            StringValues.Components[exifData[tag][1]] +\n                            StringValues.Components[exifData[tag][2]] +\n                            StringValues.Components[exifData[tag][3]];\n                        break;\n                }\n                tags[tag] = exifData[tag];\n            }\n        }\n\n        if (tags.GPSInfoIFDPointer) {\n            gpsData = readTags(file, tiffOffset, tiffOffset + tags.GPSInfoIFDPointer, GPSTags, bigEnd);\n            for (tag in gpsData) {\n                switch (tag) {\n                    case \"GPSVersionID\" :\n                        gpsData[tag] = gpsData[tag][0] +\n                            \".\" + gpsData[tag][1] +\n                            \".\" + gpsData[tag][2] +\n                            \".\" + gpsData[tag][3];\n                        break;\n                }\n                tags[tag] = gpsData[tag];\n            }\n        }\n\n        // extract thumbnail\n        tags['thumbnail'] = readThumbnailImage(file, tiffOffset, firstIFDOffset, bigEnd);\n\n        return tags;\n    }\n\n   function findXMPinJPEG(file) {\n\n        if (!('DOMParser' in self)) {\n            // console.warn('XML parsing not supported without DOMParser');\n            return;\n        }\n        var dataView = new DataView(file);\n\n        if (debug) console.log(\"Got file of length \" + file.byteLength);\n        if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\n           if (debug) console.log(\"Not a valid JPEG\");\n           return false; // not a valid jpeg\n        }\n\n        var offset = 2,\n            length = file.byteLength,\n            dom = new DOMParser();\n\n        while (offset < (length-4)) {\n            if (getStringFromDB(dataView, offset, 4) == \"http\") {\n                var startOffset = offset - 1;\n                var sectionLength = dataView.getUint16(offset - 2) - 1;\n                var xmpString = getStringFromDB(dataView, startOffset, sectionLength)\n                var xmpEndIndex = xmpString.indexOf('xmpmeta>') + 8;\n                xmpString = xmpString.substring( xmpString.indexOf( '<x:xmpmeta' ), xmpEndIndex );\n\n                var indexOfXmp = xmpString.indexOf('x:xmpmeta') + 10\n                //Many custom written programs embed xmp/xml without any namespace. Following are some of them.\n                //Without these namespaces, XML is thought to be invalid by parsers\n                xmpString = xmpString.slice(0, indexOfXmp)\n                            + 'xmlns:Iptc4xmpCore=\"http://iptc.org/std/Iptc4xmpCore/1.0/xmlns/\" '\n                            + 'xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" '\n                            + 'xmlns:tiff=\"http://ns.adobe.com/tiff/1.0/\" '\n                            + 'xmlns:plus=\"http://schemas.android.com/apk/lib/com.google.android.gms.plus\" '\n                            + 'xmlns:ext=\"http://www.gettyimages.com/xsltExtension/1.0\" '\n                            + 'xmlns:exif=\"http://ns.adobe.com/exif/1.0/\" '\n                            + 'xmlns:stEvt=\"http://ns.adobe.com/xap/1.0/sType/ResourceEvent#\" '\n                            + 'xmlns:stRef=\"http://ns.adobe.com/xap/1.0/sType/ResourceRef#\" '\n                            + 'xmlns:crs=\"http://ns.adobe.com/camera-raw-settings/1.0/\" '\n                            + 'xmlns:xapGImg=\"http://ns.adobe.com/xap/1.0/g/img/\" '\n                            + 'xmlns:Iptc4xmpExt=\"http://iptc.org/std/Iptc4xmpExt/2008-02-29/\" '\n                            + xmpString.slice(indexOfXmp)\n\n                var domDocument = dom.parseFromString( xmpString, 'text/xml' );\n                return xml2Object(domDocument);\n            } else{\n             offset++;\n            }\n        }\n    }\n\n    function xml2json(xml) {\n        var json = {};\n      \n        if (xml.nodeType == 1) { // element node\n          if (xml.attributes.length > 0) {\n            json['@attributes'] = {};\n            for (var j = 0; j < xml.attributes.length; j++) {\n              var attribute = xml.attributes.item(j);\n              json['@attributes'][attribute.nodeName] = attribute.nodeValue;\n            }\n          }\n        } else if (xml.nodeType == 3) { // text node\n          return xml.nodeValue;\n        }\n      \n        // deal with children\n        if (xml.hasChildNodes()) {\n          for(var i = 0; i < xml.childNodes.length; i++) {\n            var child = xml.childNodes.item(i);\n            var nodeName = child.nodeName;\n            if (json[nodeName] == null) {\n              json[nodeName] = xml2json(child);\n            } else {\n              if (json[nodeName].push == null) {\n                var old = json[nodeName];\n                json[nodeName] = [];\n                json[nodeName].push(old);\n              }\n              json[nodeName].push(xml2json(child));\n            }\n          }\n        }\n        \n        return json;\n    }\n\n    function xml2Object(xml) {\n        try {\n            var obj = {};\n            if (xml.children.length > 0) {\n              for (var i = 0; i < xml.children.length; i++) {\n                var item = xml.children.item(i);\n                var attributes = item.attributes;\n                for(var idx in attributes) {\n                    var itemAtt = attributes[idx];\n                    var dataKey = itemAtt.nodeName;\n                    var dataValue = itemAtt.nodeValue;\n\n                    if(dataKey !== undefined) {\n                        obj[dataKey] = dataValue;\n                    }\n                }\n                var nodeName = item.nodeName;\n\n                if (typeof (obj[nodeName]) == \"undefined\") {\n                  obj[nodeName] = xml2json(item);\n                } else {\n                  if (typeof (obj[nodeName].push) == \"undefined\") {\n                    var old = obj[nodeName];\n\n                    obj[nodeName] = [];\n                    obj[nodeName].push(old);\n                  }\n                  obj[nodeName].push(xml2json(item));\n                }\n              }\n            } else {\n              obj = xml.textContent;\n            }\n            return obj;\n          } catch (e) {\n              console.log(e.message);\n          }\n    }\n\n    EXIF.enableXmp = function() {\n        EXIF.isXmpEnabled = true;\n    }\n\n    EXIF.disableXmp = function() {\n        EXIF.isXmpEnabled = false;\n    }\n\n    EXIF.getData = function(img, callback) {\n        if (((self.Image && img instanceof self.Image)\n            || (self.HTMLImageElement && img instanceof self.HTMLImageElement))\n            && !img.complete)\n            return false;\n\n        if (!imageHasData(img)) {\n            getImageData(img, callback);\n        } else {\n            if (callback) {\n                callback.call(img);\n            }\n        }\n        return true;\n    }\n\n    EXIF.getTag = function(img, tag) {\n        if (!imageHasData(img)) return;\n        return img.exifdata[tag];\n    }\n    \n    EXIF.getIptcTag = function(img, tag) {\n        if (!imageHasData(img)) return;\n        return img.iptcdata[tag];\n    }\n\n    EXIF.getAllTags = function(img) {\n        if (!imageHasData(img)) return {};\n        var a,\n            data = img.exifdata,\n            tags = {};\n        for (a in data) {\n            if (data.hasOwnProperty(a)) {\n                tags[a] = data[a];\n            }\n        }\n        return tags;\n    }\n    \n    EXIF.getAllIptcTags = function(img) {\n        if (!imageHasData(img)) return {};\n        var a,\n            data = img.iptcdata,\n            tags = {};\n        for (a in data) {\n            if (data.hasOwnProperty(a)) {\n                tags[a] = data[a];\n            }\n        }\n        return tags;\n    }\n\n    EXIF.pretty = function(img) {\n        if (!imageHasData(img)) return \"\";\n        var a,\n            data = img.exifdata,\n            strPretty = \"\";\n        for (a in data) {\n            if (data.hasOwnProperty(a)) {\n                if (typeof data[a] == \"object\") {\n                    if (data[a] instanceof Number) {\n                        strPretty += a + \" : \" + data[a] + \" [\" + data[a].numerator + \"/\" + data[a].denominator + \"]\\r\\n\";\n                    } else {\n                        strPretty += a + \" : [\" + data[a].length + \" values]\\r\\n\";\n                    }\n                } else {\n                    strPretty += a + \" : \" + data[a] + \"\\r\\n\";\n                }\n            }\n        }\n        return strPretty;\n    }\n\n    EXIF.readFromBinaryFile = function(file) {\n        return findEXIFinJPEG(file);\n    }\n\n    if (typeof define === 'function' && define.amd) {\n        define('exif-js', [], function() {\n            return EXIF;\n        });\n    }\n}.call(this));\n\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getDataFromReadFile = exports.readFile = void 0;\nfunction readFile(file) {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = (e) => resolve(e.target.result);\n        reader.onerror = (error) => reject(error);\n        reader.readAsDataURL(file);\n    });\n}\nexports.readFile = readFile;\nasync function getDataFromReadFile(files) {\n    return await Promise.all(Array.from(files).map((file) => readFile(file)));\n}\nexports.getDataFromReadFile = getDataFromReadFile;\n","\"use strict\";\n// Thanks JavaScript-Load-Image repo\n// https://github.com/blueimp/JavaScript-Load-Image/blob/1e4df707821a0afcc11ea0720ee403b8759f3881/js/load-image-orientation.js#L37-L53\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getBrowserOrientation = void 0;\nconst readImage_1 = require(\"./readImage\");\nasync function getBrowserOrientation() {\n    // black 2x1 JPEG, with the following meta information set:\n    // EXIF Orientation: 6 (Rotated 90° CCW)\n    const testImageURL = 'data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAA' +\n        'AAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBA' +\n        'QEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE' +\n        'BAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAEAAgMBEQACEQEDEQH/x' +\n        'ABKAAEAAAAAAAAAAAAAAAAAAAALEAEAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAA' +\n        'AAAAAEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8H//2Q==';\n    const img = await readImage_1.readImage(testImageURL);\n    // Check if browser supports automatic image orientation:\n    return img.width === 1 && img.height === 2;\n}\nexports.getBrowserOrientation = getBrowserOrientation;\n"],"sourceRoot":""}